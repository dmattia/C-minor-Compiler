/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_NOT
%token TOKEN_INTEGER
%token TOKEN_PLUS
%token TOKEN_MINUS
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_DIVISION
%token TOKEN_MODULUS
%token TOKEN_NOT_EQUALS
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_EXPONENT
%token TOKEN_INTEGER_LITERAL
%token TOKEN_ASTERISK
%token TOKEN_CHAR_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_ARRAY
%token TOKEN_BOOL
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FUNCTION
%token TOKEN_IF
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_WHILE
%token TOKEN_LEFT_BRACKET
%token TOKEN_RIGHT_BRACKET
%token TOKEN_COMMA
%token TOKEN_COLON
%token TOKEN_LEFT_BRACE
%token TOKEN_RIGHT_BRACE
%token TOKEN_SEMICOLON
%token TOKEN_IDENTIFIER
%token TOKEN_FLOAT
%token TOKEN_COMMENT
%token TOKEN_STRING
%token TOKEN_UNRECOGNIZED
%token TOKEN_LT
%token TOKEN_GT
%token TOKEN_LE
%token TOKEN_GE
%token TOKEN_LEFT_PAREN
%token TOKEN_RIGHT_PAREN
%token TOKEN_EQUALS
%token TOKEN_ASSIGNMENT
%token TOKEN_WHITESPACE

%{

#include <math.h>
#include <stdio.h>

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are computing
arithmetic values as a double.
*/
#define YYSTYPE double

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

double parser_result = 0.0;

%}

%%

/* Here is the grammar: program is the start symbol. */

program		: decl_list
		;

decl_list	: decl_list decl
		| /* nothing */
		;

decl		: ident TOKEN_COLON type TOKEN_ASSIGNMENT expr TOKEN_SEMICOLON
		| ident TOKEN_COLON type TOKEN_SEMICOLON
		| ident TOKEN_COLON type TOKEN_ASSIGNMENT TOKEN_LEFT_BRACE stmt_list TOKEN_RIGHT_BRACE
		;

type		: TOKEN_STRING
		| TOKEN_INTEGER
		| TOKEN_CHAR
		| TOKEN_BOOL
		| TOKEN_ARRAY TOKEN_LEFT_BRACKET opt_expr TOKEN_RIGHT_BRACKET type
		| TOKEN_VOID
		| TOKEN_FUNCTION type TOKEN_LEFT_PAREN param_list TOKEN_RIGHT_PAREN
		;

opt_expr	: expr
		| /* nothing */
		;

param_list	: not_empty_param_list
		| /* empty param list */
		;

not_empty_param_list 	: param_list TOKEN_COMMA param
			| param
			;

param		: ident TOKEN_COLON type
		;

ident		: TOKEN_IDENTIFIER
		;

stmt_list	: stmt_list stmt
		| stmt
		;

stmt		: matched_stmt
		| unmatched_stmt
		;

matched_stmt	: TOKEN_IF TOKEN_LEFT_PAREN expr TOKEN_RIGHT_PAREN matched_stmt TOKEN_ELSE matched_stmt
		| expr TOKEN_SEMICOLON
		| TOKEN_PRINT expr_list TOKEN_SEMICOLON /* allows PRINT; */
		| TOKEN_FOR TOKEN_LEFT_PAREN opt_expr TOKEN_SEMICOLON opt_expr TOKEN_SEMICOLON opt_expr TOKEN_RIGHT_PAREN matched_stmt
		| TOKEN_LEFT_BRACE stmt_list TOKEN_RIGHT_BRACE
		| TOKEN_RETURN opt_expr TOKEN_SEMICOLON
		| decl
		;

unmatched_stmt	: TOKEN_IF TOKEN_LEFT_PAREN expr TOKEN_RIGHT_PAREN stmt
		| TOKEN_IF TOKEN_LEFT_PAREN expr TOKEN_RIGHT_PAREN matched_stmt TOKEN_ELSE unmatched_stmt
		;

expr_list	: expr_list TOKEN_COMMA expr
		| opt_expr
		;

expr		: assignment_expr
		;

assignment_expr	: ident TOKEN_ASSIGNMENT assignment_expr
		| or_expr
		;

or_expr		: or_expr TOKEN_OR and_expr
		| and_expr
		;

and_expr	: and_expr TOKEN_AND comp_expr 
		| comp_expr
		;

comp_expr	: comp_expr TOKEN_LT add_expr
		| comp_expr TOKEN_GT add_expr
		| comp_expr TOKEN_LE add_expr
		| comp_expr TOKEN_GE add_expr
		| comp_expr TOKEN_EQUALS add_expr
		| comp_expr TOKEN_NOT_EQUALS add_expr
		| add_expr
		;

add_expr	: add_expr TOKEN_PLUS mult_expr
		| add_expr TOKEN_MINUS mult_expr
		| mult_expr
		;

mult_expr	: mult_expr TOKEN_ASTERISK exponent_expr
		| mult_expr TOKEN_DIVISION exponent_expr
		| mult_expr TOKEN_MODULUS exponent_expr
		| exponent_expr
		;

exponent_expr	: exponent_expr TOKEN_EXPONENT flip_expr
		| flip_expr
		;

flip_expr	: TOKEN_MINUS flip_expr
		| TOKEN_NOT flip_expr
		| prefix_expr
		;

prefix_expr	: TOKEN_INCREMENT postfix_expr
		| TOKEN_DECREMENT postfix_expr
		| postfix_expr
		;

postfix_expr	: postfix_expr TOKEN_INCREMENT
		| postfix_expr TOKEN_DECREMENT
		| group_expr
		;

group_expr	: TOKEN_LEFT_PAREN expr TOKEN_RIGHT_PAREN
		| TOKEN_LEFT_BRACKET expr TOKEN_RIGHT_BRACKET
		| ident TOKEN_LEFT_PAREN expr_list TOKEN_RIGHT_PAREN
		| primary_expr
		;

primary_expr	: TOKEN_TRUE
		| TOKEN_FALSE
		| TOKEN_INTEGER_LITERAL
		| TOKEN_CHAR_LITERAL
		| TOKEN_STRING_LITERAL
		| ident
		| ident TOKEN_LEFT_BRACKET opt_expr TOKEN_RIGHT_BRACKET
		;

%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/
int yyerror( char *str )
{
	printf("parse error: %s\n",str);
}
